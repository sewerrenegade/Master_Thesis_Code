import numpy as np
import sys
sys.path.append('/home/milad/Desktop/Master_Thesis/code/Master_Thesis_Code')
import random
from datasets.MNIST.MNIST_base import MNIST_Dataset_Referencer
from datasets.MNIST.MNIST_base import BaseDataset as MNISTbase
from datasets.embedded_data.dataset.embedding_base import EmbeddingBaseDataset as EMNIST
import matplotlib.pyplot as plt
import os
from configs.global_config import GlobalConfig
from distance_functions.input_distance_function_metrics.interclass_distance_matrix_metrics import get_score_of_distances,calculate_softmax
import json
    
def compute_euclidean_distance(x):
    assert len(x)==2
    out_dic =np.linalg.norm(x[0] - x[1])
    return out_dic
    
def compute_distance_between_classes(distance_fn,class1,class2=None):
    if class2 is None:
        class2=class1.copy()#SHALLOW COPY
        random.shuffle(class2)
    samples = zip(class1,class2)
    distances= []
    for input_pair in samples:
        distances.append(distance_fn(input_pair))
    mean = np.mean(distances,axis=0)
    var = np.var(distances,axis=0)
    return mean,var


def save_score(mean,path,notes):
    score_dict = get_score_of_distances(mean)
    score_serialize = json.dumps(score_dict)
    with open(os.path.join(path,"score.txt"), "w") as file:
        file.write(notes)
        file.write("\n\n")
        file.write(score_serialize)
    return score_dict


def calculate_interclass_distances(data,classes,distance_fn):
    class_count = len(classes)
    mean_distance_matrix = np.zeros((class_count,class_count))
    var_distance_matrix = np.zeros((class_count,class_count))
    for i in range(class_count):
            for j in range(i, class_count):
                if i != j:
                    mean_distance_matrix[i,j],var_distance_matrix[i,j] =  compute_distance_between_classes(distance_fn,data[classes[i]],data[classes[j]])
                    mean_distance_matrix[j,i],var_distance_matrix[j,i] = mean_distance_matrix[i,j],var_distance_matrix[i,j]
                else:
                    mean_distance_matrix[i,i],var_distance_matrix[i,i]= compute_distance_between_classes(distance_fn,data[classes[i]])
    return mean_distance_matrix,var_distance_matrix

def standardize_array(array):
    avg = np.mean(array)
    std = np.std(array)
    return (array-avg)/std
#the input looks like this [d1[mean,var],d2[mean,var]]


def visualize_array(mean_distance,variance_of_distance_matrix,name, path,metrics_dict = {}):
    fig, axs = plt.subplots(1, 3, figsize=(20, 10))
    fig.suptitle(f"Interclass Distance generated by {name} embedding", fontsize=30)
    normalized_mean = mean_distance#standardize_array(mean_distance)
    normalized_var = standardize_array(variance_of_distance_matrix)
    soft_max_mean = calculate_softmax(mean_distance)
    im0 = axs[0].imshow(soft_max_mean, cmap='viridis')
    axs[0].set_title(f"Prediction Generated by softmax prediction", fontsize=20)
    im1 = axs[1].imshow(normalized_mean, cmap='viridis')
    axs[1].set_title(f"Average Distance", fontsize=20)
    im2 = axs[2].imshow(normalized_var, cmap='viridis')
    axs[2].set_title("Variance of Distance", fontsize=20)

    fig.colorbar(im1, ax=axs[0], fraction=0.046, pad=0.04)
    fig.colorbar(im2, ax=axs[1], fraction=0.046, pad=0.04)
    fig.colorbar(im0, ax=axs[2], fraction=0.046, pad=0.04)

    metrics_text = '    '.join([f'{key}: {value:.2f}' for key, value in metrics_dict.items()])
    plt.gcf().text(0.25, 0.85, metrics_text, fontsize=24, verticalalignment='top')
    save_path = os.path.join(path,"interclass_embedded_distances.png")
    plt.savefig(save_path)
    plt.close(fig)

def get_directory_path(name):
    path = os.path.join(GlobalConfig.RESULTS_FOLDER_PATH,GlobalConfig.FashionMNIST_INTER_CLASS_DIST,GlobalConfig.EMBEDDING_RESULTS,name)
    if not os.path.exists(path):
        os.mkdir(path)
    return path

def test_embedding(embedding_name,database,classes,distance_fn = compute_euclidean_distance,notes = ""):
    path = get_directory_path(embedding_name)
    mean,var = calculate_interclass_distances(database,classes,distance_fn)
    metrics  = save_score(mean,path,notes)
    visualize_array(mean,var,embedding_name,path, metrics_dict= metrics)
    return metrics
    

def load_n_samples_from_EMNIST(NUMBER_OF_SAMPLES_PER_CLASS,embedding_name):
    samples = {}
    embeddings = EMNIST(f"data/FashionMNIST/embeddings/{embedding_name}/")
    for class_label in MNIST_Dataset_Referencer.INDEXER.classes:
        indicies = embeddings.class_indicies[class_label][:NUMBER_OF_SAMPLES_PER_CLASS]
        instances_of_class = []
        for index in indicies:
            instances_of_class.append(embeddings[index][0])
            assert embeddings[index][1] == class_label
        samples[class_label] = instances_of_class
    return  samples

def save_method_metrics_wrt_downprojection_dim(methode_name,metrics,down_dim):
    num_metrics = len(metrics[0])
    fig, axs = plt.subplots(num_metrics, 1, figsize=(10, 5 * num_metrics))

    if num_metrics == 1:
        axs = [axs]

    for i, key in enumerate(metrics[0].keys()):
        y_values = [d[key] for d in metrics]
        axs[i].plot(down_dim, y_values, marker='o', linestyle='-', label=key)
        axs[i].set_title(key, fontsize=16)
        axs[i].set_xlabel('Dimension')
        axs[i].set_ylabel('Metric')
        axs[i].legend()

    fig.suptitle(f"Metrics Plots for {methode_name}", fontsize=20)
    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    path = os.path.join(GlobalConfig.RESULTS_FOLDER_PATH,GlobalConfig.FashionMNIST_INTER_CLASS_DIST,f"{methode_name}metrics_plots.png")
    plt.savefig(path)
    plt.close(fig)


if __name__ == '__main__':
    down_dim = [1,2,3,8,16,32,64]
    order_of_embeddings = ["PHATE","ISOMAP","PCA","TSNE","UMAP"]#
    for method in order_of_embeddings:
        metrics = []
        for dim in down_dim:
            name = f"{method}_{dim}"
            print(f"started metrics calculation for {name}")
            classes  = MNIST_Dataset_Referencer.INDEXER.classes
            data  = load_n_samples_from_EMNIST(NUMBER_OF_SAMPLES_PER_CLASS=100,embedding_name= name)
            metrics.append(test_embedding(name,data, MNIST_Dataset_Referencer.INDEXER.classes,notes = 'second test'))
            print(f"finished generating embeddings for {name} saved in path ")
        save_method_metrics_wrt_downprojection_dim(methode_name=method,metrics= metrics,down_dim=down_dim)
        

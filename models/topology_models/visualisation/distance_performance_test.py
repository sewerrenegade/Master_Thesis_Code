import numpy as np
import random
import matplotlib.pyplot as plt
import os
from configs.global_config import GlobalConfig
from models.topology_models.distances.distance_matrix_metrics import get_score_of_distances,calculate_softmax
import json

    
def compute_euclidean_distance(x):
    assert len(x)==2
    out_dic =np.linalg.norm(x[0] - x[1])
    return out_dic

    
def compute_distance_between_classes(distance_fn,class1,class2=None):
    if class2 is None:
        class2=class1.copy()#SHALLOW COPY
        random.shuffle(class2)
    samples = zip(class1,class2)
    distances= []
    for input_pair in samples:
        distances.append(distance_fn(input_pair))
    mean = np.mean(distances,axis=0)
    var = np.var(distances,axis=0)
    return mean,var


def test_embedding(name,data,classes,distance_fn = compute_euclidean_distance,test_notes = ""):
    path = get_directory_path(name)
    mean,var = calculate_class_distance(data,classes,distance_fn)
    visualize_array(mean,var,name)
    save_score(mean,path,test_notes)

def save_score(mean,path,notes):
    score_dict = get_score_of_distances(mean)
    score_serialize = json.dumps(score_dict)
    with open(os.path.join(path,"score.txt"), "w") as file:
        file.write(notes)
        file.write("\n\n")
        file.write(score_serialize)



def calculate_class_distance(data,classes,distance_fn):
    class_count = len(classes)
    mean_distance_matrix = np.zeros((class_count,class_count))
    var_distance_matrix = np.zeros((class_count,class_count))
    for i in range(class_count):
            for j in range(i, class_count):
                if i != j:
                    mean_distance_matrix[i,j],var_distance_matrix[i,j] =  compute_distance_between_classes(distance_fn,data[classes[i]],data[classes[j]])
                    mean_distance_matrix[j,i],var_distance_matrix[j,i] = mean_distance_matrix[i,j],var_distance_matrix[i,j]
                else:
                    mean_distance_matrix[i,i],var_distance_matrix[i,i]= compute_distance_between_classes(distance_fn,data[classes[i]])
    return mean_distance_matrix,var_distance_matrix

def standardize_array(array):
    avg = np.mean(array)
    std = np.std(array)
    return (array-avg)/std
#the input looks like this [d1[mean,var],d2[mean,var]]


def visualize_array(mean_distance,variance_of_distance_matrix,name):
    fig, axs = plt.subplots(1, 3, figsize=(10, 20))
    fig.suptitle(f"Interclass Distance generated by {name} embedding")

    # normalized_mean = (mean - np.min(mean)) / (np.max(mean) - np.min(mean))
    # normalized_var = (var - np.min(var)) / (np.max(var) - np.min(var))   
    normalized_mean = standardize_array(mean_distance)
    normalized_var = standardize_array(variance_of_distance_matrix)
    soft_max_mean = calculate_softmax(mean_distance)
    im0 = axs[0,1].imshow(soft_max_mean, cmap='viridis')
    axs[0,1].set_title(f"Prediction Generated by softmax prediction")
    im1 = axs[0,1].imshow(normalized_mean, cmap='viridis')
    axs[0,1].set_title(f"Average Distance")
    im2 = axs[0,2].imshow(normalized_var, cmap='viridis')
    axs[0,2].set_title("Variance of Distance")

    fig.colorbar(im1, ax=axs[0,0], fraction=0.046, pad=0.04)
    fig.colorbar(im2, ax=axs[0,1], fraction=0.046, pad=0.04)
    fig.colorbar(im0, ax=axs[0,2], fraction=0.046, pad=0.04)
    directory_path = get_directory_path(name)
    save_path = os.path.join(directory_path,"interclass_embedded_distances.png")
    plt.savefig(save_path)

def get_directory_path(name):
    return os.path.join(GlobalConfig.RESULTS_FOLDER_PATH,GlobalConfig.INTER_CLASS_DIST,name)


